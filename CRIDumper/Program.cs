using System;
using System.Collections.Generic;
using System.IO;
using System.Text;

namespace CRIDumper
{
    class Program
    {

        // The following license is for the content copied (and slightly modified) from the Blackmagic Cintel SDK and for all references to it in this file. There will be a comment indicating the start and end of the Cintel SDK content.
        // The references to it in the code are obvious and self-explanatory.
        /* -LICENSE-START-
         ** Copyright (c) 2018 Blackmagic Design
         **
         ** Permission is hereby granted, free of charge, to any person or organization
         ** obtaining a copy of the software and accompanying documentation covered by
         ** this license (the "Software") to use, reproduce, display, distribute,
         ** execute, and transmit the Software, and to prepare derivative works of the
         ** Software, and to permit third-parties to whom the Software is furnished to
         ** do so, all subject to the following:
         **
         ** The copyright notices in the Software and this entire statement, including
         ** the above license grant, this restriction and the following disclaimer,
         ** must be included in all copies of the Software, in whole or in part, and
         ** all derivative works of the Software, unless such copies or derivative
         ** works are solely in the form of machine-executable object code generated by
         ** a source language processor.
         **
         ** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
         ** IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
         ** FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
         ** SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
         ** FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
         ** ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
         ** DEALINGS IN THE SOFTWARE.
         ** -LICENSE-END-
         */
        // Start of Blackmagic Cintel SDK content
        enum Key : UInt32
        {
            Header = 1,
            FrameInfo = 100,        // [ width, height, ColorModel, Endianness ]
            CodecType = 101,
            CodecName = 102,        // used since Resolve 14.3 (Cintel 2.1) for compressed RAW files
            FrameData = 103,        // pixel data (can be uncompressed or JPEG compressed)
            Negative = 104,     // obsolete, replaced by FilmType
            FlipHorizontal = 105,
            FlipVertical = 106,
            FilmFrameRate = 107,
            FilmType = 108,
            LinearMask = 109,       // 3 x 3
            TimeCode = 110,
            FilmGauge = 111,
            LogMask = 112,      // 3 x 3
            OffsetDetectedH = 113,      // integer stabilization in horizontal direction
            OffsetDetectedV = 114,      // integer stabilization in vertical direction
            ExtendedRange = 115,
            Keykode = 116,
            StabilizerEnabledH = 117,
            StabilizerEnabledV = 118,
            TileSizes = 119,        // 1 x 4, used since Resolve 14.3 (Cintel 2.1) for compressed RAW files
            Gains = 120,        // 1 x 3
            Lifts = 121,        // 1 x 3
            HDRGains = 122,     // 1 x 3
            OffsetToApplyH = 123,      // floating point sub-pixel stabilization in horizontal direction
            OffsetToApplyV = 124,      // floating point sub-pixel stabilization in vertical direction
            SkewToApply = 125,      // floating point skew
            Filler = 1000,      // used by applications that require frame data to be aligned on a particular boundary
        };
        enum ColorModel
        {
            COLOR_MODEL_BAYER_GRGR_CINTEL_10 = 45,

            COLOR_MODEL_BAYER_BGGR_CINTEL_12 = 76,
            COLOR_MODEL_BAYER_GBGB_CINTEL_12 = 77,
            COLOR_MODEL_BAYER_RGRG_CINTEL_12 = 78,
            COLOR_MODEL_BAYER_GRGR_CINTEL_12 = 79,

            COLOR_MODEL_BAYER_BGGR_CINTEL_16 = 88,
            COLOR_MODEL_BAYER_GBGB_CINTEL_16 = 89,
            COLOR_MODEL_BAYER_RGRG_CINTEL_16 = 90,
            COLOR_MODEL_BAYER_GRGR_CINTEL_16 = 91,
        };
        enum ContainerCodecType
        {
            CODEC_TYPE_NONE = 0,
            CODEC_TYPE_VIDEO
        };
        // End of Blackmagic Cintel SDK content

        static void Main(string[] args)
        {
            Dictionary<UInt32, byte[]> tags;

            args = new string[]{ @"H:\Programming\RawBayer2DNG\test images\cri\3\Cintel\Cintel_00086864.cri"};

            Console.WriteLine((Key)12);
            foreach (string arg in args)
            {
                tags = readCRITagData(arg);

                string genericSeparator = @"\,";

                StringBuilder sb = new StringBuilder();
                sb.AppendLine("tagname/number,interpreted,hex");
                foreach(KeyValuePair<UInt32,byte[]> tag in tags)
                {
                    if((Key)tag.Key != Key.FrameData && (Key)tag.Key != Key.Filler) {


                        sb.Append((Key)tag.Key);
                        sb.Append(",");

                        string stuff;

                        switch ((Key)tag.Key)
                        {
                            case Key.FrameInfo:
                                int width = (int)BitConverter.ToUInt32(tag.Value, 0);
                                int height = (int)BitConverter.ToUInt32(tag.Value, 4);
                                ColorModel colorModel = (ColorModel)BitConverter.ToUInt32(tag.Value, 8);
                                sb.Append(width+"x"+height+ genericSeparator + colorModel);
                                break;

                            // Bool
                            case Key.StabilizerEnabledH:
                            case Key.StabilizerEnabledV:
                            case Key.FlipHorizontal:
                            case Key.FlipVertical:
                                stuff = Helpers.byteArrayToString<bool>(tag.Value, genericSeparator);
                                sb.Append(stuff);
                                break;
                            // UInt64
                            case Key.TileSizes:
                                stuff = Helpers.byteArrayToString<UInt64>(tag.Value, genericSeparator);
                                sb.Append(stuff);
                                break;

                            // String
                            case Key.CodecName:
                                stuff = System.Text.Encoding.Default.GetString(tag.Value);
                                sb.Append(stuff);
                                break;

                            // floats
                            case Key.FilmFrameRate:
                            case Key.OffsetToApplyH:
                            case Key.OffsetToApplyV:
                            case Key.SkewToApply:
                            case Key.LinearMask:
                            case Key.LogMask:
                            case Key.Gains:
                            case Key.Lifts:
                            case Key.HDRGains:
                                //string stuff = Helpers.arrayToString<float>(Helpers.byteArrayTo<float>(tag.Value), genericSeparator);
                                stuff = Helpers.byteArrayToString<float>(tag.Value, genericSeparator);
                                sb.Append(stuff);
                                break;
                            default:
                                sb.Append("[no interpretation implemented]");
                                break;
                        }
                        sb.Append(",");

                        foreach (byte b in tag.Value)
                        {

                            sb.AppendFormat("{0:x2}", b);
                        }
                        sb.AppendLine();
                    }
                }
                File.WriteAllText(arg + ".tags.csv", sb.ToString());
            }

        }

        static private Dictionary<UInt32, byte[]> readCRITagData(string path)
        {
            Dictionary<UInt32, byte[]> tagData = new Dictionary<UInt32, byte[]>();
            UInt32 currentTag;
            UInt32 currentTagLength;
            byte[] currentTagData;
            using (BinaryReader reader = new BinaryReader(File.Open(path, FileMode.Open, FileAccess.Read, FileShare.Read)))
            {
                while (reader.BaseStream.Position < (reader.BaseStream.Length - 1))
                {

                    currentTag = reader.ReadUInt32();
                    if (currentTag == 0)
                    {
                        continue;
                    }
                    currentTagLength = reader.ReadUInt32();
                    currentTagData = reader.ReadBytes((int)currentTagLength);
                    tagData.Add(currentTag, currentTagData);
                }
            }
            return tagData;
        }

    }
}
