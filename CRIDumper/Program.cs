using System;
using System.Collections.Generic;
using System.IO;
using System.Text;

namespace CRIDumper
{
    class Program
    {

        // The following license is for the content copied (and slightly modified) from the Blackmagic Cintel SDK and for all references to it in this file. There will be a comment indicating the start and end of the Cintel SDK content.
        // The references to it in the code are obvious and self-explanatory.
        /* -LICENSE-START-
         ** Copyright (c) 2018 Blackmagic Design
         **
         ** Permission is hereby granted, free of charge, to any person or organization
         ** obtaining a copy of the software and accompanying documentation covered by
         ** this license (the "Software") to use, reproduce, display, distribute,
         ** execute, and transmit the Software, and to prepare derivative works of the
         ** Software, and to permit third-parties to whom the Software is furnished to
         ** do so, all subject to the following:
         **
         ** The copyright notices in the Software and this entire statement, including
         ** the above license grant, this restriction and the following disclaimer,
         ** must be included in all copies of the Software, in whole or in part, and
         ** all derivative works of the Software, unless such copies or derivative
         ** works are solely in the form of machine-executable object code generated by
         ** a source language processor.
         **
         ** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
         ** IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
         ** FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
         ** SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
         ** FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
         ** ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
         ** DEALINGS IN THE SOFTWARE.
         ** -LICENSE-END-
         */
        // Start of Blackmagic Cintel SDK content
        enum Key : UInt32
        {
            Header = 1,
            FrameInfo = 100,        // [ width, height, ColorModel, Endianness ]
            CodecType = 101,
            CodecName = 102,        // used since Resolve 14.3 (Cintel 2.1) for compressed RAW files
            FrameData = 103,        // pixel data (can be uncompressed or JPEG compressed)
            Negative = 104,     // obsolete, replaced by FilmType
            FlipHorizontal = 105,
            FlipVertical = 106,
            FilmFrameRate = 107,
            FilmType = 108,
            LinearMask = 109,       // 3 x 3
            TimeCode = 110,
            FilmGauge = 111,
            LogMask = 112,      // 3 x 3
            OffsetDetectedH = 113,      // integer stabilization in horizontal direction
            OffsetDetectedV = 114,      // integer stabilization in vertical direction
            ExtendedRange = 115,
            Keykode = 116,
            StabilizerEnabledH = 117,
            StabilizerEnabledV = 118,
            TileSizes = 119,        // 1 x 4, used since Resolve 14.3 (Cintel 2.1) for compressed RAW files
            Gains = 120,        // 1 x 3
            Lifts = 121,        // 1 x 3
            HDRGains = 122,     // 1 x 3
            OffsetToApplyH = 123,      // floating point sub-pixel stabilization in horizontal direction
            OffsetToApplyV = 124,      // floating point sub-pixel stabilization in vertical direction
            SkewToApply = 125,      // floating point skew
            Filler = 1000,      // used by applications that require frame data to be aligned on a particular boundary
        };
        enum ColorModel
        {
            COLOR_MODEL_BAYER_GRGR_CINTEL_10 = 45,

            COLOR_MODEL_BAYER_BGGR_CINTEL_12 = 76,
            COLOR_MODEL_BAYER_GBGB_CINTEL_12 = 77,
            COLOR_MODEL_BAYER_RGRG_CINTEL_12 = 78,
            COLOR_MODEL_BAYER_GRGR_CINTEL_12 = 79,

            COLOR_MODEL_BAYER_BGGR_CINTEL_16 = 88,
            COLOR_MODEL_BAYER_GBGB_CINTEL_16 = 89,
            COLOR_MODEL_BAYER_RGRG_CINTEL_16 = 90,
            COLOR_MODEL_BAYER_GRGR_CINTEL_16 = 91,
        };
        enum ContainerCodecType
        {
            CODEC_TYPE_NONE = 0,
            CODEC_TYPE_VIDEO
        };
        enum FilmType
        {
            Positive = 0,
		    Negative = 1,
		    InterPositive = 2,
		    InterNegative = 3
	    };

        enum FilmGauge
        {
            Gauge16mm = 0,
		    Gauge35mm2Perf = 1,
		    Gauge35mm3Perf = 2,
		    Gauge35mm4Perf = 3
	    };
        enum Endianness
        {
            ENDIAN_BIG = 0,
            ENDIAN_LITTLE
        };
        // End of Blackmagic Cintel SDK content

        static void Main(string[] args)
        {
            Dictionary<UInt32, byte[]> tags;

            //args = new string[]{ @"H:\Programming\RawBayer2DNG\test images\cri\3\Cintel\Cintel_00086864.cri"};
            //args = new string[]{ @"H:\Programming\RawBayer2DNG\test images\cri\3\Cintel\.HDR\Cintel_00089040.cri" };

            Console.WriteLine((Key)12);
            foreach (string arg in args)
            {
                tags = readCRITagData(arg);

                string genericSeparator = ",";

                StringBuilder sb = new StringBuilder();
                sb.AppendLine("tagname/number,interpreted,hex");
                foreach(KeyValuePair<UInt32,byte[]> tag in tags)
                {
                    if((Key)tag.Key != Key.FrameData && (Key)tag.Key != Key.Filler) {


                        sb.Append((Key)tag.Key);
                        sb.Append(",");
                        sb.Append('"');

                        string stuff;

                        switch ((Key)tag.Key)
                        {
                            case Key.FrameInfo:
                                int width = (int)BitConverter.ToUInt32(tag.Value, 0);
                                int height = (int)BitConverter.ToUInt32(tag.Value, 4);
                                ColorModel colorModel = (ColorModel)BitConverter.ToUInt32(tag.Value, 8);
                                Endianness endianness = (Endianness)BitConverter.ToUInt32(tag.Value, 12);
                                sb.Append(width+"x"+height+ genericSeparator + colorModel+genericSeparator+ endianness);
                                break;

                            // Bool
                            case Key.ExtendedRange: // Unverified
                            case Key.StabilizerEnabledH:
                            case Key.StabilizerEnabledV:
                            case Key.FlipHorizontal:
                            case Key.FlipVertical:
                            case Key.Negative: // Unverified
                                stuff = Helpers.byteArrayToString<bool>(tag.Value, genericSeparator);
                                sb.Append(stuff);
                                break;
                            // UInt64
                            case Key.Keykode: // Unverified
                            case Key.TileSizes:
                                stuff = Helpers.byteArrayToString<UInt64>(tag.Value, genericSeparator);
                                sb.Append(stuff);
                                break;
                            // UInt16
                            case Key.OffsetDetectedH: // Unverified
                            case Key.OffsetDetectedV:// Unverified
                                stuff = Helpers.byteArrayToString<UInt16>(tag.Value, genericSeparator);
                                sb.Append(stuff);
                                break;

                            // String
                            case Key.Header:
                            case Key.CodecName:
                            case Key.TimeCode:
                                stuff = System.Text.Encoding.Default.GetString(tag.Value);
                                sb.Append(stuff);
                                break;

                            // Specialized
                            case Key.CodecType:
                                stuff = ((ContainerCodecType)BitConverter.ToUInt32(tag.Value)).ToString();
                                sb.Append(stuff);
                                break;
                            case Key.FilmType:
                                stuff = ((FilmType)tag.Value[0]).ToString();
                                sb.Append(stuff);
                                break;
                            case Key.FilmGauge:
                                stuff = ((FilmGauge)tag.Value[0]).ToString();
                                sb.Append(stuff);
                                break;

                            // floats
                            case Key.FilmFrameRate:
                            case Key.OffsetToApplyH:
                            case Key.OffsetToApplyV:
                            case Key.SkewToApply:
                            case Key.LinearMask:
                            case Key.LogMask:
                            case Key.Gains:
                            case Key.Lifts:
                            case Key.HDRGains:
                                //string stuff = Helpers.arrayToString<float>(Helpers.byteArrayTo<float>(tag.Value), genericSeparator);
                                stuff = Helpers.byteArrayToString<float>(tag.Value, genericSeparator);
                                sb.Append(stuff);
                                break;
                            default:
                                sb.Append("[no interpretation implemented]");
                                break;
                        }
                        sb.Append('"');
                        sb.Append(",");

                        foreach (byte b in tag.Value)
                        {

                            sb.AppendFormat("{0:x2}", b);
                        }
                        sb.AppendLine();
                    }
                }
                File.WriteAllText(arg + ".tags.csv", sb.ToString());

                // Now dump the actual data.
                if (tags.ContainsKey((UInt32)Key.FrameData))
                {

                    // Detect compression
                    // Only horizontal tiles are supported so far. Assuming there is no vertical tiling.
                    if (tags.ContainsKey((UInt32)Key.TileSizes))
                    {

                        byte[] tileSizeData = tags[(UInt32)Key.TileSizes];
                        int tileCount = tileSizeData.Length / 8; // The tilesizes are saved as Uint64s I think, so dividing by 8 should give the right number.

                        UInt64 totalSizeFromTileSizes = 0;
                        UInt64[] tileSizes = new UInt64[tileCount];
                        for (int i = 0; i < tileCount; i++)
                        {
                            tileSizes[i] = BitConverter.ToUInt64(tileSizeData, i * 8);
                            totalSizeFromTileSizes += tileSizes[i];
                        }

                        byte[] compressedData = tags[(UInt32)Key.FrameData];



                        byte[] tmpBuffer;
                        UInt64 alreadyRead = 0;
                        UInt64 index = 0;
                        foreach (UInt64 tileSize in tileSizes)
                        {
                            tmpBuffer = new byte[tileSize];
                            index++;

                            Array.Copy(compressedData, (int)alreadyRead, tmpBuffer, 0, (int)tileSize);
                            alreadyRead += tileSize;
                            File.WriteAllBytes(arg + ".tile." + index + ".jpg", tmpBuffer);
                        }
                    }
                    else
                    {

                        // Presuming uncompressed
                        File.WriteAllBytes(arg + ".data.raw", tags[(UInt32)Key.FrameData]);
                    }

                    //File.WriteAllBytes("rawcri.jpg", tagData[(UInt32)Key.FrameData]);

                }
            }

        }

        static private Dictionary<UInt32, byte[]> readCRITagData(string path)
        {
            Dictionary<UInt32, byte[]> tagData = new Dictionary<UInt32, byte[]>();
            UInt32 currentTag;
            UInt32 currentTagLength;
            byte[] currentTagData;
            using (BinaryReader reader = new BinaryReader(File.Open(path, FileMode.Open, FileAccess.Read, FileShare.Read)))
            {
                while (reader.BaseStream.Position < (reader.BaseStream.Length - 3))
                {

                    currentTag = reader.ReadUInt32();
                    if (currentTag == 0)
                    {
                        continue;
                    }
                    currentTagLength = reader.ReadUInt32();
                    currentTagData = reader.ReadBytes((int)currentTagLength);
                    tagData.Add(currentTag, currentTagData);
                }
            }
            return tagData;
        }

    }
}
